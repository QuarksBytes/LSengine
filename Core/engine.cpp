#ifndef __ENGINE_CPP__
#define __ENGINE_CPP__

#include<vector>
#include<cstdint>

#include"Componant.cpp"
#include"Design.cpp"
#include"Error/ls_error.cpp"
#include"Lua/lua.cpp"

#define FLAGS_ENGINE_STARTED 1

enum ModulaInputState{
  MODULE_STATE_INCOMPLETE,
  MODULE_STATE_COMPLETE,
  MODULE_STATE_ERROR
};

struct ModuleState{
  Componant* componant;
  ModulaInputState state;
};

class Engine{
private:

  Lua luaLogical;
  Lua luaElectrical;

  Design& circuitDesign;
  //buffer list to  run
  std::list<ModuleState> runModulesList[2];

  uint32_t current=0;

  uint32_t flags=0;


public:


  Engine(Design& Design): circuitDesign(Design){
    //TODO
    //load the lua script for the engine
    //luaLogical.load("engine.lua");
    //luaElectrical.load("engine.lua");
      
  }




/*
 *
 * returns id for accessing the elements in engine again ,
 * id can never be 0,
 * if it is 0 then an error has occured
 *
 */
  uint32_t addComponant(Componant& m){
    if(flags&FLAGS_ENGINE_STARTED){
      LSError::SetError("Engine has already started, cannot add more modules");
      return 0;
    }

    return circuitDesign.addComponant(m);
  }

  

  /**
 * Executes the given module and processes its logic.
 * 
 * This function runs the logic of the provided module and determines the output modules
 * that should be forwarded to the next stage of execution. The function is expected to
 * handle the module's internal logic and return a list of components that are affected
 * or generated as a result of the module's execution.
 * 
 * @param module A pointer to the module (Componant) to be executed.
 * @return A list of references to the output components generated by the module.
 *         These components will be added to the next execution queue.
 */
  std::list<Componant&> runModule(Componant* module){
    

    std::list<Componant&> outputModules;
    
    //TODO

    return outputModules;

  }




  void runLogical(){
    //TODO
    //run the modules in the current queue and add the output modules to the next queue
    //after running all modules in the current queue, swap the queues and repeat until no more modules to run

    int currentRunningListIndex=0;

    //fill the first run queue with the input modules
    for(auto& module : circuitDesign.components){
      if(module.second.type == INPUT){
        ModuleState state;
        state.componant = &module.second; // Assign the address of the module
        state.state = MODULE_STATE_INCOMPLETE;
        runModulesList[currentRunningListIndex].push_back(state);
      }
    }

    while(runModulesList[currentRunningListIndex].size() >0){ // loop as long as there is element in current list

         for(auto& moduleState : runModulesList[currentRunningListIndex]){
          //run compoannt if it has all input group is completed
            if(moduleState.state == MODULE_STATE_COMPLETE){
              // run the module at current running list
              auto forwardedComponants = runModule(moduleState.componant);
             //moving new componants to the next running list
              runModulesList[currentRunningListIndex^1].insert(
              runModulesList[currentRunningListIndex^1].end(),
              forwardedComponants.begin(),
              forwardedComponants.end()
          );
        }

      }// end of running list modules
      
      currentRunningListIndex^=1; // swap the running list index
      runModulesList[currentRunningListIndex].clear(); // clear the current running list

     }




  }






};

#undef FLAGS_ENGINE_STARTED

#endif
